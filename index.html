<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø§Ø¨Ø²Ø§Ø± Ù¾ÛŒØ§Ù…â€ŒØ±Ø³Ø§Ù† Ù¾Ù†Ù‡Ø§Ù†</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Firebase SDK Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, addDoc, onSnapshot, collection, query, orderBy, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Expose Firebase modules to the global scope for use in the main script
        window.firebase = {
            initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged,
            getFirestore, doc, addDoc, onSnapshot, collection, query, orderBy, serverTimestamp,
            setLogLevel
        };
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700&display=swap');
        body {
            font-family: 'Vazirmatn', sans-serif;
            background-color: #1a1a2e;
            color: #e4e4e7;
        }
        .chat-container {
            background-color: #2c2c54;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            max-height: 90vh;
        }
        .chat-messages {
            height: calc(90vh - 200px); /* Adjust based on input area height */
            overflow-y: auto;
            display: flex;
            flex-direction: column-reverse; /* Latest message at the bottom */
        }
        .chat-bubble {
            max-width: 80%;
            padding: 8px 12px;
            border-radius: 18px;
            word-wrap: break-word;
        }
        .self-message {
            background-color: #5d5d8e; /* User's own message */
            align-self: flex-end;
            margin-left: auto;
        }
        .other-message {
            background-color: #4b4b7a; /* Other user's message */
            align-self: flex-start;
            margin-right: auto;
        }
        textarea, input[type="text"] {
            background-color: #3b3b6b;
            border-color: #5d5d8e;
            color: #e4e4e7;
        }
        /* Style for the revealed secret */
        .secret-reveal {
             background-color: #0d322c;
             border: 1px dashed #a7f3d0;
             color: #a7f3d0;
             font-weight: 700;
             padding: 6px;
             margin-top: 4px;
             font-size: 0.9rem;
        }
        /* Custom scrollbar for dark theme */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2c2c54;
        }
        ::-webkit-scrollbar-thumb {
            background: #5d5d8e;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #7a7ab3;
        }
    </style>
</head>
<body class="p-4 md:p-8 min-h-screen flex items-center justify-center">

    <div class="w-full max-w-2xl chat-container p-4 md:p-6 rounded-xl space-y-4 flex flex-col">
        <h1 class="text-2xl md:text-3xl font-bold text-center text-indigo-300 border-b border-indigo-700 pb-3">
            Ù¾ÛŒØ§Ù…â€ŒØ±Ø³Ø§Ù† Ù¾Ù†Ù‡Ø§Ù† ğŸ’¬
        </h1>
        
        <!-- User ID & Status -->
        <div class="text-center text-sm mb-4">
            <p id="authStatus" class="text-yellow-400">... Ø¯Ø± Ø­Ø§Ù„ Ø§ØªØµØ§Ù„</p>
            <p class="text-xs mt-1 text-gray-400">Ø´Ù†Ø§Ø³Ù‡ Ø´Ù…Ø§: <span id="currentUserId" class="font-mono text-xs">Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ</span></p>
        </div>

        <!-- Key Input -->
        <div class="space-y-2 border-4 border-yellow-500 rounded-xl p-3 bg-yellow-900/20">
            <label for="keywordInput" class="block text-lg font-bold text-yellow-300">
                Ù¾Ø§Ø±Ø§Ù…ØªØ±:
            </label>
            <input type="text" id="keywordInput" value="secret" placeholder="Ù¾Ø§Ø±Ø§Ù…ØªØ± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯"
                   class="w-full p-2 rounded-lg border-2 text-base font-mono text-center border-yellow-500 focus:ring-yellow-400 focus:border-yellow-400 text-white transition duration-150">
        </div>

        <!-- Chat Messages Area -->
        <div id="chatMessages" class="chat-messages p-2 space-y-4 mb-4">
            <p class="text-center text-gray-500 pt-8">Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ Ø¯Ø± Ø§ÛŒÙ†Ø¬Ø§ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯.</p>
        </div>
        
        <!-- Input Area -->
        <div class="border-t border-indigo-700 pt-4 space-y-2">
             <!-- Real Input Text Area (Handles user input, transparent, exactly layered) -->
             <div class="relative">
                <!-- 1. Decoy Text Area (Always visible, shows the decoy text, read-only) -->
                <textarea id="decoyInputText" rows="2" readonly 
                          placeholder="Ù¾ÛŒØ§Ù… Ø®ÙˆØ¯ Ø±Ø§ Ø§ÛŒÙ†Ø¬Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯..."
                          class="w-full p-3 rounded-lg border-2 resize-none transition duration-150 border-gray-600 bg-gray-700/50 text-gray-400"></textarea>

                <!-- 2. Real Input Text Area (Handles user input, transparent, exactly layered) -->
                <textarea id="realInputText" rows="2" 
                          placeholder="" 
                          class="absolute top-0 left-0 w-full h-full p-3 rounded-lg border-2 resize-none focus:outline-none focus:border-green-500" 
                          style="caret-color: white; color: transparent; background: transparent;"></textarea>
            </div>
            
            <button id="sendBtn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-xl text-lg transition duration-150">
                Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… (ØªÙˆÙ„ÛŒØ¯)
            </button>
        </div>
        
        <!-- Alert Message -->
        <div id="alertMessage" class="hidden text-center p-3 rounded-lg bg-indigo-800 text-indigo-100 font-medium transition duration-300" role="alert">
            Ø¹Ù…Ù„ÛŒØ§Øª Ù…ÙˆÙÙ‚ÛŒØª Ø¢Ù…ÛŒØ² Ø¨ÙˆØ¯!
        </div>
    </div>

    <script type="module">
        // Global variables provided by the canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // --- CONSTANTS ---
        const KEYWORD_STORAGE_KEY = 'vigenere_param';
        const CHAT_COLLECTION_PATH = `/artifacts/${appId}/public/data/chat_messages`;
        
        // These are required for the steganography logic
        const DECOY_TEXT_FULL = ""; 
        // ** ØªØºÛŒÛŒØ± Ø¹Ø¨Ø§Ø±Øª ÙØ±ÛŒØ¨Ù†Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø¹Ù…ÙˆÙ…ÛŒâ€ŒØªØ± Ø´Ø¯Ù† **
        const DECOY_PHRASE = "ÛŒÚ© Ù¾ÛŒØ§Ù… Ø¹Ù…ÙˆÙ…ÛŒ Ø­Ø§ÙˆÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª "; 
        
        // Zero-Width Character Map
        const INVISIBLE_CHARS = {
            '00': '\u200B', '01': '\u200C', 
            '10': '\u200D', '11': '\uFEFF',
        };
        const VISIBLE_BITS = {
            '\u200B': '00', '\u200C': '01',
            '\u200D': '10', '\uFEFF': '11',
        };

        // --- Element References ---
        const realInputText = document.getElementById('realInputText'); 
        const decoyInputText = document.getElementById('decoyInputText'); 
        const keywordInput = document.getElementById('keywordInput'); 
        const sendBtn = document.getElementById('sendBtn');
        const chatMessagesDiv = document.getElementById('chatMessages');
        const alertMessage = document.getElementById('alertMessage');
        const authStatus = document.getElementById('authStatus');
        const currentUserIdSpan = document.getElementById('currentUserId');
        
        // --- FIREBASE GLOBALS ---
        let app;
        let db;
        let auth;
        let currentUserId = null;
        let messageRevealTimers = {}; // To manage auto-hide timers for individual messages

        // --- Utility Functions ---
        
        function getUserIdDisplay(id) {
            // This is the full user ID as required for multi-user apps
            return id; 
        }

        function showAlert(message, duration = 3000) {
            alertMessage.textContent = message;
            alertMessage.classList.remove('hidden', 'bg-indigo-800', 'bg-red-800', 'bg-green-800');
            let bgColor = 'bg-indigo-800'; 
            if (message.includes('Ø®Ø·Ø§') || message.includes('âŒ')) {
                bgColor = 'bg-red-800';
            } else if (message.includes('Ù…ÙˆÙÙ‚')) {
                bgColor = 'bg-green-800';
            }
            alertMessage.classList.add(bgColor);
            clearTimeout(alertMessage.timer);
            alertMessage.timer = setTimeout(() => {
                alertMessage.classList.add('hidden');
            }, duration);
        }

        // --- Steganography & Cipher Functions (Vigenere + Zero-Width) ---

        function b64EncodeUnicode(str) {
            return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,
                function(match, p1) {
                    return String.fromCharCode('0x' + p1);
                }));
        }

        function b64DecodeUnicode(str) {
            return decodeURIComponent(atob(str).split('').map(function(c) {
                return '%' + ('00' + c.codePointAt(0).toString(16)).slice(-2);
            }).join(''));
        }

        function encodeToInvisible(text) {
            let binary = '';
            for (let i = 0; i < text.length; i++) {
                let byte = text.codePointAt(i);
                binary += byte.toString(2).padStart(8, '0');
            }
            let invisible = '';
            for (let i = 0; i < binary.length; i += 2) {
                const quad = binary.substring(i, i + 2);
                if (quad.length === 2) {
                    invisible += INVISIBLE_CHARS[quad];
                }
            }
            return invisible;
        }

        function decodeFromInvisible(invisibleText) {
            let binary = '';
            for (let i = 0; i < invisibleText.length; i++) {
                const char = invisibleText[i];
                if (VISIBLE_BITS[char]) {
                    binary += VISIBLE_BITS[char];
                }
            }
            let resultText = '';
            for (let i = 0; i < binary.length; i += 8) {
                const byteString = binary.substring(i, i + 8);
                if (byteString.length === 8) {
                    const charCode = parseInt(byteString, 2);
                    resultText += String.fromCodePoint(charCode);
                }
            }
            return resultText;
        }

        function vigenereCipher(text, keyword, decrypt = false) {
            let result = '';
            const CLEANED_KEYWORD = keyword.trim();
            if (CLEANED_KEYWORD.length === 0) return text; 
            const KEYWORD_LENGTH = CLEANED_KEYWORD.length;

            for (let i = 0, j = 0; i < text.length; i++, j++) {
                let keyCharIndex = j % KEYWORD_LENGTH;
                let keyChar = CLEANED_KEYWORD.codePointAt(keyCharIndex);
                if (keyChar > 0xFFFF) j++; 
                
                let textChar = text.codePointAt(i);
                if (textChar > 0xFFFF) i++; 
                
                let shift = decrypt ? -keyChar : keyChar;
                let newCodePoint = textChar + shift;
                
                result += String.fromCodePoint(newCodePoint);
            }
            return result;
        }
        
        function decryptMessageContent(covertData, keyword) {
            try {
                if (covertData.length === 0) throw new Error("Ø¯Ø§Ø¯Ù‡ Ù…Ø®ÙÛŒ Ø®Ø§Ù„ÛŒ Ø§Ø³Øª.");
                if (keyword.trim() === "") throw new Error("Ù¾Ø§Ø±Ø§Ù…ØªØ± Ù†Ø§Ù…Ø¹ØªØ¨Ø±.");

                // 1. Decode invisible ZW-chars back to Base64 ASCII string
                const base64Cipher = decodeFromInvisible(covertData);

                // 2. Base64 Decode the string to get the RAW Vigenere cipher text
                const realCipher = b64DecodeUnicode(base64Cipher);

                // 3. Decrypt the real cipher text
                const decryptedText = vigenereCipher(realCipher, keyword, true); 
                
                return decryptedText;
            } catch (e) {
                console.error("Decryption Error:", e);
                return `âŒ Ø®Ø·Ø§ Ø¯Ø± Ø±Ù…Ø²Ú¯Ø´Ø§ÛŒÛŒ: ${e.message}`;
            }
        }


        // --- Decoy Display Management ---
        
        function updateDecoyDisplay() {
            const realLength = realInputText.value.length;
            if (realLength === 0) {
                decoyInputText.value = '';
                decoyInputText.placeholder = 'Ù¾ÛŒØ§Ù… Ø®ÙˆØ¯ Ø±Ø§ Ø§ÛŒÙ†Ø¬Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯...';
                return;
            }
            
            const repeatCount = Math.ceil(realLength / DECOY_PHRASE.length) + 1;
            let decoyDisplay = DECOY_PHRASE.repeat(repeatCount).substring(0, realLength);
            
            decoyInputText.value = decoyDisplay;
            decoyInputText.scrollTop = realInputText.scrollTop;
        }

        // --- Firebase Handlers ---

        async function initializeFirebase() {
            if (!firebaseConfig) {
                authStatus.textContent = "Ø®Ø·Ø§: Ù¾ÛŒÚ©Ø±Ø¨Ù†Ø¯ÛŒ Firebase Ù…ÙˆØ¬ÙˆØ¯ Ù†ÛŒØ³Øª. (Ù„Ø·ÙØ§ Canvas Ø±Ø§ Ù…Ø¬Ø¯Ø¯Ø§ Ø§Ø¬Ø±Ø§ Ú©Ù†ÛŒØ¯.)";
                return;
            }
            
            try {
                // setLogLevel('debug'); // Enable for debugging
                app = firebase.initializeApp(firebaseConfig);
                db = firebase.getFirestore(app);
                auth = firebase.getAuth(app);

                // Handle Authentication
                authStatus.textContent = "Ø¯Ø± Ø­Ø§Ù„ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª...";
                
                if (initialAuthToken) {
                    await firebase.signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await firebase.signInAnonymously(auth);
                }

                firebase.onAuthStateChanged(auth, (user) => {
                    if (user) {
                        currentUserId = user.uid;
                        currentUserIdSpan.textContent = getUserIdDisplay(currentUserId);
                        authStatus.textContent = "âœ… Ù…ØªØµÙ„";
                        setupRealtimeListener();
                    } else {
                        currentUserId = null;
                        currentUserIdSpan.textContent = "Ù†Ø§Ø´Ù†Ø§Ø³";
                        authStatus.textContent = "âŒ Ù‚Ø·Ø¹ Ø§ØªØµØ§Ù„";
                    }
                });
                
            } catch (e) {
                authStatus.textContent = `Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„: ${e.message}`;
                console.error("Firebase Initialization Error:", e);
            }
        }
        
        async function sendMessage() {
            if (!currentUserId) {
                showAlert("âŒ Ø§Ø¨ØªØ¯Ø§ Ø¨Ø§ÛŒØ¯ Ù…ØªØµÙ„ Ø´ÙˆÛŒØ¯.", 4000);
                return;
            }
            
            const realMessage = realInputText.value.trim();
            const keyword = keywordInput.value;

            if (keyword.trim() === "") {
                showAlert("Ø®Ø·Ø§: Ù¾Ø§Ø±Ø§Ù…ØªØ± Ù„Ø§Ø²Ù… Ø§Ø³Øª.", 4000);
                return;
            }
            if (realMessage === "") {
                 showAlert("Ø®Ø·Ø§: Ù¾ÛŒØ§Ù… Ù„Ø§Ø²Ù… Ø§Ø³Øª.", 3000);
                return;
            }

            try {
                // 1. Vigenere Encrypt (Raw Unicode string)
                const realCipher = vigenereCipher(realMessage, keyword, false);
                
                // 2. Base64 Encode the RAW cipher (ASCII-safe string)
                const base64Cipher = b64EncodeUnicode(realCipher);

                // 3. Convert Base64 string to a completely invisible string of Zero-Width characters
                const invisibleCipher = encodeToInvisible(base64Cipher);

                // 4. Construct the final output
                const finalOutput = DECOY_TEXT_FULL + invisibleCipher;
                
                // 5. Save to Firestore
                await firebase.addDoc(firebase.collection(db, CHAT_COLLECTION_PATH), {
                    senderId: currentUserId,
                    timestamp: firebase.serverTimestamp(),
                    covertData: finalOutput,
                    // Store the visible part length to help frontend rendering (optional, but good practice)
                    visibleLength: realMessage.length 
                });

                // Clear input fields
                realInputText.value = ''; 
                decoyInputText.value = '';
                
                showAlert("Ù¾ÛŒØ§Ù… Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯.", 3000);

            } catch (e) {
                showAlert(`Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù…: ${e.message}`, 7000);
                console.error("Send Message Error:", e);
            }
        }

        function setupRealtimeListener() {
            if (!db || !currentUserId) return;

            const q = firebase.query(
                firebase.collection(db, CHAT_COLLECTION_PATH),
                firebase.orderBy('timestamp', 'desc') // Get latest first
            );

            // Listen for real-time updates
            firebase.onSnapshot(q, (snapshot) => {
                chatMessagesDiv.innerHTML = ''; // Clear existing messages (simplest way to re-render)
                
                // Filter and process new messages
                const messages = [];
                snapshot.forEach(doc => {
                    messages.push({ id: doc.id, ...doc.data() });
                });

                if (messages.length === 0) {
                    chatMessagesDiv.innerHTML = '<p class="text-center text-gray-500 pt-8">Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ Ø¯Ø± Ø§ÛŒÙ†Ø¬Ø§ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯.</p>';
                    return;
                }

                messages.forEach(message => {
                    const messageElement = createMessageElement(message);
                    chatMessagesDiv.appendChild(messageElement);
                });
                
                // Keep the scroll at the bottom (due to flex-direction: column-reverse)
                chatMessagesDiv.scrollTop = 0;
            }, (error) => {
                console.error("Firestore Listen Error:", error);
                showAlert("Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§.", 5000);
            });
        }
        
        function createMessageElement(message) {
            const isSelf = message.senderId === currentUserId;
            const messageWrapper = document.createElement('div');
            messageWrapper.className = `flex mb-4 ${isSelf ? 'justify-end' : 'justify-start'} w-full`;
            
            // Determine the decoy text length based on the encoded data
            const invisibleCipherLength = message.covertData.length;
            const repeatCount = Math.ceil(message.visibleLength / DECOY_PHRASE.length) + 1;
            const decoyText = DECOY_PHRASE.repeat(repeatCount).substring(0, message.visibleLength || 20) + '...'; // Add ... for visual cue

            // Format timestamp if available
            let timeStr = '';
            if (message.timestamp && message.timestamp.toDate) {
                const date = message.timestamp.toDate();
                timeStr = date.toLocaleTimeString('fa-IR', { hour: '2-digit', minute: '2-digit' });
            }

            messageWrapper.innerHTML = `
                <div class="flex flex-col max-w-xs sm:max-w-md w-full">
                    <div class="text-xs ${isSelf ? 'text-gray-400 text-left' : 'text-yellow-300 text-right'} mb-1 px-3">
                        ${isSelf ? `Ø´Ù…Ø§ (${getUserIdDisplay(message.senderId)})` : getUserIdDisplay(message.senderId)}
                    </div>
                    <div id="bubble-${message.id}" class="chat-bubble ${isSelf ? 'self-message' : 'other-message'} cursor-pointer">
                        <p class="text-white">${decoyText}</p>
                        <div id="secret-${message.id}" class="secret-reveal hidden mt-2">...</div>
                        <p class="text-xs ${isSelf ? 'text-gray-300' : 'text-gray-400'} mt-1 text-left">${timeStr}</p>
                    </div>
                </div>
            `;
            
            const bubble = messageWrapper.querySelector(`#bubble-${message.id}`);
            bubble.addEventListener('click', () => handleMessageClick(message.id, message.covertData));

            return messageWrapper;
        }

        function handleMessageClick(messageId, covertData) {
            const secretDiv = document.getElementById(`secret-${messageId}`);
            const keyword = keywordInput.value;
            
            // Clear any existing timer for this message
            if (messageRevealTimers[messageId]) {
                clearTimeout(messageRevealTimers[messageId]);
                delete messageRevealTimers[messageId];
            }

            // Decrypt and display
            const decryptedText = decryptMessageContent(covertData, keyword);
            secretDiv.textContent = decryptedText;
            secretDiv.classList.remove('hidden');

            // Set auto-hide timer (5 seconds)
            messageRevealTimers[messageId] = setTimeout(() => {
                secretDiv.classList.add('hidden');
                delete messageRevealTimers[messageId];
            }, 5000); // 5 seconds delay
        }


        // --- Event Listeners and Initialization ---

        window.onload = function() {
            // Load key from local storage
            const savedKeyword = localStorage.getItem(KEYWORD_STORAGE_KEY);
            if (savedKeyword) {
                keywordInput.value = savedKeyword;
            } else {
                localStorage.setItem(KEYWORD_STORAGE_KEY, keywordInput.value);
            }
            
            initializeFirebase();

            // Handle input events on the REAL input to update the visual decoy
            realInputText.addEventListener('input', updateDecoyDisplay);
            realInputText.addEventListener('scroll', () => {
                 decoyInputText.scrollTop = realInputText.scrollTop;
            });

            // Send Button click
            sendBtn.addEventListener('click', sendMessage);

            // Send on Enter key (not Shift+Enter)
            realInputText.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault(); 
                    sendMessage();
                }
            });

            // Save keyword to localStorage on every change
            keywordInput.addEventListener('input', (e) => {
                 localStorage.setItem(KEYWORD_STORAGE_KEY, e.target.value);
            });
        };
    </script>
</body>
</html>
